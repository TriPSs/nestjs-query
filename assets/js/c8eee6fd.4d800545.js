"use strict";(self.webpackChunknestjs_query=self.webpackChunknestjs_query||[]).push([[2879],{286:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var s=n(4848),r=n(8453);const o={title:"Multiple Databases"},i=void 0,c={id:"persistence/typeorm/multiple-databases",title:"Multiple Databases",description:"TypeOrm offers the possibility to connect your application to multiple databases or schemas. More details on this can be found on their official documentation.",source:"@site/docs/persistence/typeorm/multiple-databases.md",sourceDirName:"persistence/typeorm",slug:"/persistence/typeorm/multiple-databases",permalink:"/nestjs-query/docs/persistence/typeorm/multiple-databases",draft:!1,unlisted:!1,editUrl:"https://github.com/tripss/nestjs-query/edit/master/documentation/docs/persistence/typeorm/multiple-databases.md",tags:[],version:"current",frontMatter:{title:"Multiple Databases"},sidebar:"docs",previous:{title:"Custom Service",permalink:"/nestjs-query/docs/persistence/typeorm/custom-service"},next:{title:"Soft Delete",permalink:"/nestjs-query/docs/persistence/typeorm/soft-delete"}},a={},l=[{value:"Defining multiple connections",id:"defining-multiple-connections",level:2},{value:"Create a new Feature Module",id:"create-a-new-feature-module",level:2},{value:"Custom TypeOrmQueryService",id:"custom-typeormqueryservice",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"TypeOrm"})," offers the possibility to connect your application to multiple databases or schemas. More details on this can be found on their ",(0,s.jsx)(t.a,{href:"https://typeorm.io/#/multiple-connections",children:"official documentation"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Further, the official ",(0,s.jsx)(t.code,{children:"@nestjs/typeorm"})," package also provides functionality to support multiple databases within the application. For details, consider the ",(0,s.jsx)(t.a,{href:"https://docs.nestjs.com/techniques/database#multiple-databases",children:"official documentation"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Therefore, ",(0,s.jsx)(t.code,{children:"@ptc-org/nestjs-query-typeorm"})," also offers this functionality. This section will walk you through a short example indicating how to connect your application to multiple databases. Further, this will assume, that you ",(0,s.jsx)(t.strong,{children:"already have a working application with a configured database"}),". Please note that only key aspects are shown here:"]}),"\n",(0,s.jsx)(t.h2,{id:"defining-multiple-connections",children:"Defining multiple connections"}),"\n",(0,s.jsx)(t.p,{children:"First lets set up a constants file to hold our connection names."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="constants.ts"',children:"export const MUSIC_DB_CONNECTION = 'default';\nexport const SECRET_DB_CONNECTION = 'secret';\n"})}),"\n",(0,s.jsx)(t.p,{children:"Then setup multiple database connections."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="app.module.ts"',children:"import { MUSIC_DB_CONNECTION, SECRET_DB_CONNECTION } from './constants';\n\nconst musicEntities = [\n  ArtistEntity,\n  AlbumEntity,\n  SongEntity,\n  GenreEntity,\n  // ...\n];\n\nconst secretEntities = [SecretEntity];\n\n@Module({\n  imports: [\n    ConfigModule.forRoot(environment),\n    TypeOrmModule.forRoot({\n      // name: MUSIC_DB_CONNECTION, // if you leave this out, this will be the \"default\" connection!\n      type: \"postgres\",\n      host: \"localhost\",\n      port: 5436,\n      username: 'user',\n      password: 'password',\n      database: 'music',\n      synchronize: true,\n      logging: true,\n      entities: musicEntities,\n    }),\n    // this also works with the ASYNC configuration!\n    TypeOrmModule.forRootAsync({\n      name: SECRET_DB_CONNECTION,   // you need to set the name here!\n      imports: [ConfigModule],\n      inject: [ConfigService],\n      useFactory: (configService: ConfigService): TypeOrmModuleOptions => ({\n        ...configService.get('dbConnections.secret'),\n        entities: secretEntities,\n      }),\n    }),\n    GraphQLModule.forRootAsync({\n      // ...\n    }),\n    // other modules\n  ],\n  controllers: [],\n  providers: [],\n})\nexport class AppModule {}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Of course, there can only be one ",(0,s.jsx)(t.code,{children:"default"})," database connection. All other connections ",(0,s.jsx)(t.strong,{children:"must"})," have a proper ",(0,s.jsx)(t.code,{children:"name"})," set up. Further, this name ",(0,s.jsx)(t.strong,{children:"must"})," be used when connecting against this specific entity."]}),"\n",(0,s.jsx)(t.h2,{id:"create-a-new-feature-module",children:"Create a new Feature Module"}),"\n",(0,s.jsx)(t.p,{children:"Second, you need to create a new module for the feature that should store its data in another database using the previously defined connection."}),"\n",(0,s.jsxs)(t.p,{children:["First, define your ",(0,s.jsx)(t.code,{children:"Entity"})," class that is stored within the database"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="secret/secret.entity.ts"',children:"import { Entity, Column } from 'typeorm';\n\n@Entity('secrets')\nexport class SecretEntity {\n  // some properties here, like\n  @Column()\n  name: string;\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["and the corresponding ",(0,s.jsx)(t.code,{children:"ObjectType"})," that is used for ",(0,s.jsx)(t.code,{children:"GraphQL"})]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="secret/secret.dto.ts"',children:"import { ObjectType, Field } from '@nestjs/graphql';\n\n@ObjectType('Secret')\nexport class SecretDTO {\n  @Field()\n  name: string;\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Now lets register the ",(0,s.jsx)(t.code,{children:"SecretEntity"})," with ",(0,s.jsx)(t.code,{children:"NestjsQueryTypeOrmModule"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["The only difference is you need to pass the name of the ",(0,s.jsx)(t.code,{children:"Connection"})," when importing respective ",(0,s.jsx)(t.code,{children:"TypeOrmModule"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="secret/secret.module.ts"',children:"import { Module } from '@nestjs/common';\nimport { NestjsQueryGraphQLModule } from '@ptc-org/nestjs-query-graphql';\nimport { NestjsQueryTypeOrmModule } from '@ptc-org/nestjs-query-typeorm'; \nimport { SECRET_DB_CONNECTION } from '../constants';\nimport { SecretEntity } from './secret.entity';\nimport { SecretDTO } from './secret.dto'\n\n@Module({\n  imports: [\n    NestjsQueryGraphQLModule.forFeature({\n      // import the NestjsQueryTypeOrmModule to register the entity with typeorm\n      // and provide a QueryService\n      imports: [\n        NestjsQueryTypeOrmModule.forFeature(\n          [SecretEntity], \n          SECRET_DB_CONNECTION, // specify the connection name\n        )\n      ],\n      // describe the resolvers you want to expose\n      resolvers: [{ DTOClass: SecretDTO, EntityClass: SecretEntity }],\n    }),\n    \n  ],  \n})\nexport class SecretModule {}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Now the ",(0,s.jsx)(t.code,{children:"NestjsQueryGraphQLModule"})," will create a ",(0,s.jsx)(t.code,{children:"Resolver"})," for the ",(0,s.jsx)(t.code,{children:"SecretDTO"})," and ",(0,s.jsx)(t.code,{children:"SecretEntity"})," that will use the custom connection."]}),"\n",(0,s.jsx)(t.h2,{id:"custom-typeormqueryservice",children:"Custom TypeOrmQueryService"}),"\n",(0,s.jsxs)(t.p,{children:["If you want to create a custom ",(0,s.jsx)(t.code,{children:"SecretService"})," responsible for the database access, a custom ",(0,s.jsx)(t.a,{href:"/nestjs-query/docs/persistence/services",children:"QueryService"}),", you need to pass an additional argument to the ",(0,s.jsx)(t.code,{children:"@InjectRepository()"})," decorator that indicates the ",(0,s.jsx)(t.code,{children:"Connection"})," you are using. This string has to match the ",(0,s.jsx)(t.code,{children:"name"})," property in the ",(0,s.jsx)(t.code,{children:"TypeOrmModule"})," options!"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",metastring:'title="secret/secret.service.ts"',children:"import { QueryService } from '@ptc-org/nestjs-query-core';\nimport { TypeOrmQueryService } from '@ptc-org/nestjs-query-typeorm';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { SECRET_DB_CONNECTION } from '../constants';\nimport { SecretEntity } from './secret.entity';\n\n@QueryService(SecretEntity)\nexport class SecretService extends TypeOrmQueryService<SecretEntity> {\n  constructor(\n    @InjectRepository(SecretEntity, SECRET_DB_CONNECTION) repository: Repository<SecretEntity>,\n  ) {\n    super(repository);\n  }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["For the sake of brevity, the ",(0,s.jsx)(t.code,{children:"AssemblerService"})," is not covered here, as it should not directly interact with the database itself. Therefore, no further adaptations are required. This also applies to the ",(0,s.jsx)(t.code,{children:"Resolver"}),"!"]}),"\n",(0,s.jsxs)(t.p,{children:["For a full example see the ",(0,s.jsx)(t.a,{href:"https://github.com/tripss/nestjs-query/tree/master/examples/typeorm-multidb",children:"examples"}),"."]})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>c});var s=n(6540);const r={},o=s.createContext(r);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);