"use strict";(self.webpackChunknestjs_query=self.webpackChunknestjs_query||[]).push([[2076],{1326:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>a,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>c,toc:()=>d});var n=s(4848),o=s(8453);const i={title:"Testing Services"},r=void 0,c={id:"persistence/typeorm/testing-services",title:"Testing Services",description:"It is possible to test services that use TypeOrmQueryService. The process is similar to the one described for nestjs, but it has a few differences.",source:"@site/docs/persistence/typeorm/testing-services.md",sourceDirName:"persistence/typeorm",slug:"/persistence/typeorm/testing-services",permalink:"/nestjs-query/docs/persistence/typeorm/testing-services",draft:!1,unlisted:!1,editUrl:"https://github.com/tripss/nestjs-query/edit/master/documentation/docs/persistence/typeorm/testing-services.md",tags:[],version:"current",frontMatter:{title:"Testing Services"},sidebar:"docs",previous:{title:"Soft Delete",permalink:"/nestjs-query/docs/persistence/typeorm/soft-delete"},next:{title:"Getting Started",permalink:"/nestjs-query/docs/persistence/sequelize/getting-started"}},a={},d=[{value:"Mocking Inherited Methods",id:"mocking-inherited-methods",level:2}];function l(e){const t={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["It is possible to test services that use ",(0,n.jsx)(t.code,{children:"TypeOrmQueryService"}),". The process is similar to the one described for ",(0,n.jsx)(t.a,{href:"https://docs.nestjs.com/techniques/database#testing",children:"nestjs"}),", but it has a few differences."]}),"\n",(0,n.jsxs)(t.p,{children:["Let's assume we have the following ",(0,n.jsx)(t.code,{children:"TodoItem"})," service. For the sake of completeness, let's also add a dependency on another service (let's pretend that the todos have subTasks; we are not using relationships here):"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",metastring:'title="todo-item.service.ts"',children:"import { InjectQueryService, QueryService } from '@ptc-org/nestjs-query-core';\nimport { TypeOrmQueryService } from '@ptc-org/nestjs-query-typeorm';\nimport { Repository } from 'typeorm';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { SubTaskEntity } from '../sub-task/sub-task.entity';\nimport { TodoItemEntity } from './todo-item.entity';\n\n@QueryService(TodoItemEntity)\nexport class TodoItemService extends TypeOrmQueryService<TodoItemEntity> {\n  constructor(\n    @InjectRepository(TodoItemEntity) private todosRepository: Repository<TodoItemEntity>,\n    @InjectQueryService(SubTaskEntity) private subTaskService: QueryService<SubTaskEntity>,\n  ) {\n    super(todosRepository);\n  }\n\n  async getWithSubTasks(id: number): Promise<{ todoItem: TodoItemEntity; subTasks: SubTaskEntity[] }> {\n    const todoItem = await this.todosRepository.findOneOrFail(id);\n    const subTasks = await this.subTaskService.query({ filter: { todoItemId: { eq: id } } });\n    return { todoItem, subTasks };\n  }\n}\n\n"})}),"\n",(0,n.jsx)(t.p,{children:"Now lets write some tests!"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",metastring:'title="todo-item.service.spec.ts"',children:"import { Test, TestingModule } from '@nestjs/testing';\nimport { getQueryServiceToken } from '@ptc-org/nestjs-query-core';\nimport { getRepositoryToken } from '@nestjs/typeorm';\nimport { plainToClass } from 'class-transformer';\nimport { TodoItemEntity } from '../src/todo-item/todo-item.entity';\nimport { SubTaskEntity } from '../src/sub-task/sub-task.entity';\nimport { TodoItemService } from '../src/todo-item/todo-item.service';\n\n// We create some fake entiites, just for testing. Here they are empty,\n// but they can be more complex, depending on the testing cases.\nconst subTasks = [new SubTaskEntity(), new SubTaskEntity(), new SubTaskEntity()];\nconst oneTodo: TodoItemEntity = plainToClass(TodoItemEntity, { id: 1, title: 'A test todo' });\n\ndescribe('TodosItemService', () => {\n  let service: TodoItemService; // Removed type, compared to the nestjs examples\n\n  // We mock the responses of the two services. \n  // The mocks in this example are very simple, but they can be more complex, depending on the test cases.\n\n  const mockedSubTaskService = {\n    // mock the query method that is used by getWithSubTasks\n    query: jest.fn((query) => Promise.resolve(subTasks)),\n  };  \n  const mockedRepo = {\n    // mock the repo `findOneOrFail`\n    findOneOrFail: jest.fn((id) => Promise.resolve(oneTodo)),\n  };\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        // Provide the original service\n        TodoItemService,\n        // Mock the repository using the `getRepositoryToken` from @nestjs/typeorm\n        {\n          provide: getRepositoryToken(TodoItemEntity),\n          useValue: mockedRepo,\n        },\n        // Mock the SubTask QueryService using the `getQueryServiceToken` from @ptc-org/nestjs-query-core\n        {\n          provide: getQueryServiceToken(SubTaskEntity),\n          useValue: mockedSubTaskService,\n        },\n      ],\n    }).compile();\n    // get the service from the testing module.\n    service = await module.get(TodoItemService);\n  });\n\n  // reset call counts and called with arguments after each spec\n  afterEach(() => jest.clearAllMocks());\n\n  // Now we are ready to write the tests.\n  describe('getWithSubTasks', () => {\n    it('should return a TodoItem with subTasks', async () => {\n      // We can use jest spies to inspect if functions are called ...\n\n      // create a spy for the repository findOneOrFail method\n      const findOneOrFailSpy = jest.spyOn(mockedRepo, 'findOneOrFail');\n      // create a spy for the mocked subTaskService query method\n      const querySpy = jest.spyOn(mockedSubTaskService, 'query');\n\n      // When we call a service function the following things happen:\n      // - the real service function is called, so we can test its code\n      // - the mocked repository method is called\n      // - the mocked subTask query service method is called\n      // note that if the service calls a function in a repo or query service that is not defined by a mock, the test\n      // will fail\n      const todo = await service.getWithSubTasks(oneTodo.id);\n      // check the result against the expected results\n      expect(todo).toEqual({ todoItem: oneTodo, subTasks });\n\n      // Ensure that the spies are called once with the appropriate arguments\n      expect(findOneOrFailSpy).toHaveBeenCalledTimes(1);\n      expect(findOneOrFailSpy).toHaveBeenCalledWith(oneTodo.id);\n      expect(querySpy).toHaveBeenCalledTimes(1);\n      expect(querySpy).toHaveBeenCalledWith({ filter: { todoItemId: { eq: oneTodo.id } } });\n    });\n  });\n});\n\n"})}),"\n",(0,n.jsx)(t.h2,{id:"mocking-inherited-methods",children:"Mocking Inherited Methods"}),"\n",(0,n.jsx)(t.p,{children:"You can also mock inherited methods."}),"\n",(0,n.jsxs)(t.p,{children:["Let's change the ",(0,n.jsx)(t.code,{children:"getWithSubTasks"})," method from the ",(0,n.jsx)(t.code,{children:"TodoItemService"})," to use the ",(0,n.jsx)(t.code,{children:"getById"})," method from the parent ",(0,n.jsx)(t.code,{children:"TypeOrmQueryService"})]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"async getWithSubTasks(id: number): Promise<{ todoItem: TodoItemEntity; subTasks: SubTaskEntity[] }> {\n  const todoItem = await this.getById(id);\n  const subTasks = await this.subTaskService.query({ filter: { todoItemId: { eq: id } } });\n  return { todoItem, subTasks };\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["To mock the ",(0,n.jsx)(t.code,{children:"getById"})," method we can create a new ",(0,n.jsx)(t.code,{children:"spy"})," with a mock implementation"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"const getByIdSpy = jest.spyOn(service, 'getById').mockImplementation(() => Promise.resolve(oneTodo));\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Lets update our tests to mock out the ",(0,n.jsx)(t.code,{children:"getById"})," implementation"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-ts",children:"describe('getWithSubTasks', () => {\n  it('should return a TodoItem with subTasks', async () => {\n    // We can use jest spies to inspect if functions are called ...\n\n    // create a mock implementation for getById on the service\n    const getByIdSpy = jest.spyOn(service, 'getById').mockImplementation(() => Promise.resolve(oneTodo));\n    // create a spy for the mocked subTaskService query method\n    const querySpy = jest.spyOn(mockedSubTaskService, 'query');\n\n    // When we call a service function the following things happen:\n    // - the real service function is called, so we can test its code\n    // - the mock todoItem query service method is called\n    // - the mocked subTask query service method is called\n    // note that if the service calls a function in a repo or query service that is not defined by a mock, the test\n    // will fail\n    const todo = await service.getWithSubTasks(oneTodo.id);\n    // check the result against the expected results\n    expect(todo).toEqual({ todoItem: oneTodo, subTasks });\n\n    // Ensure that the spies are called once with the appropriate arguments\n    expect(getByIdSpy).toHaveBeenCalledTimes(1);\n    expect(getByIdSpy).toHaveBeenCalledWith(oneTodo.id);\n    expect(querySpy).toHaveBeenCalledTimes(1);\n    expect(querySpy).toHaveBeenCalledWith({ filter: { todoItemId: { eq: oneTodo.id } } });\n  });\n\n  it('should reject if the getById rejects with an error', async () => {\n    // We can use jest spies to inspect if functions are called ...\n\n    // create a mock implementation for the service getById method\n    const getByIdSpy = jest.spyOn(service, 'getById').mockImplementation(() => Promise.reject(new Error('foo')));\n    // create a spy for the mocked subTaskService query method\n    const querySpy = jest.spyOn(mockedSubTaskService, 'query');\n\n    // When we call a service function the following things happen:\n    // - the real service function is called, so we can test its code\n    // - the mocked repository method is called\n    // - the mocked subTask query service method is called\n    // note that if the service calls a function in a repo or query service that is not defined by a mock, the test\n    // will fail\n    await expect(service.getWithSubTasks(oneTodo.id)).rejects.toThrow('foo');\n\n    // Ensure that the getById spy is called one\n    expect(getByIdSpy).toHaveBeenCalledTimes(1);\n    expect(getByIdSpy).toHaveBeenCalledWith(oneTodo.id);\n    // Ensure that that the querySpy was not called  \n    expect(querySpy).not.toHaveBeenCalled();\n  });\n});\n"})})]})}function m(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,t,s)=>{s.d(t,{R:()=>r,x:()=>c});var n=s(6540);const o={},i=n.createContext(o);function r(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);