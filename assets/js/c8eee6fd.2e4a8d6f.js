"use strict";(self.webpackChunknestjs_query=self.webpackChunknestjs_query||[]).push([[2879],{1369:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>c,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"persistence/typeorm/multiple-databases","title":"Multiple Databases","description":"TypeOrm offers the possibility to connect your application to multiple databases or schemas. More details on this can be found on their official documentation.","source":"@site/docs/persistence/typeorm/multiple-databases.md","sourceDirName":"persistence/typeorm","slug":"/persistence/typeorm/multiple-databases","permalink":"/nestjs-query/docs/persistence/typeorm/multiple-databases","draft":false,"unlisted":false,"editUrl":"https://github.com/tripss/nestjs-query/edit/master/documentation/docs/persistence/typeorm/multiple-databases.md","tags":[],"version":"current","frontMatter":{"title":"Multiple Databases"},"sidebar":"docs","previous":{"title":"Custom Service","permalink":"/nestjs-query/docs/persistence/typeorm/custom-service"},"next":{"title":"Soft Delete","permalink":"/nestjs-query/docs/persistence/typeorm/soft-delete"}}');var r=n(4848),o=n(8453);const i={title:"Multiple Databases"},c=void 0,a={},l=[{value:"Defining multiple connections",id:"defining-multiple-connections",level:2},{value:"Create a new Feature Module",id:"create-a-new-feature-module",level:2},{value:"Custom TypeOrmQueryService",id:"custom-typeormqueryservice",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"TypeOrm"})," offers the possibility to connect your application to multiple databases or schemas. More details on this can be found on their ",(0,r.jsx)(t.a,{href:"https://typeorm.io/#/multiple-connections",children:"official documentation"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Further, the official ",(0,r.jsx)(t.code,{children:"@nestjs/typeorm"})," package also provides functionality to support multiple databases within the application. For details, consider the ",(0,r.jsx)(t.a,{href:"https://docs.nestjs.com/techniques/database#multiple-databases",children:"official documentation"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["Therefore, ",(0,r.jsx)(t.code,{children:"@ptc-org/nestjs-query-typeorm"})," also offers this functionality. This section will walk you through a short example indicating how to connect your application to multiple databases. Further, this will assume, that you ",(0,r.jsx)(t.strong,{children:"already have a working application with a configured database"}),". Please note that only key aspects are shown here:"]}),"\n",(0,r.jsx)(t.h2,{id:"defining-multiple-connections",children:"Defining multiple connections"}),"\n",(0,r.jsx)(t.p,{children:"First lets set up a constants file to hold our connection names."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",metastring:'title="constants.ts"',children:"export const MUSIC_DB_CONNECTION = 'default';\nexport const SECRET_DB_CONNECTION = 'secret';\n"})}),"\n",(0,r.jsx)(t.p,{children:"Then setup multiple database connections."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",metastring:'title="app.module.ts"',children:"import { MUSIC_DB_CONNECTION, SECRET_DB_CONNECTION } from './constants';\n\nconst musicEntities = [\n  ArtistEntity,\n  AlbumEntity,\n  SongEntity,\n  GenreEntity,\n  // ...\n];\n\nconst secretEntities = [SecretEntity];\n\n@Module({\n  imports: [\n    ConfigModule.forRoot(environment),\n    TypeOrmModule.forRoot({\n      // name: MUSIC_DB_CONNECTION, // if you leave this out, this will be the \"default\" connection!\n      type: \"postgres\",\n      host: \"localhost\",\n      port: 5436,\n      username: 'user',\n      password: 'password',\n      database: 'music',\n      synchronize: true,\n      logging: true,\n      entities: musicEntities,\n    }),\n    // this also works with the ASYNC configuration!\n    TypeOrmModule.forRootAsync({\n      name: SECRET_DB_CONNECTION,   // you need to set the name here!\n      imports: [ConfigModule],\n      inject: [ConfigService],\n      useFactory: (configService: ConfigService): TypeOrmModuleOptions => ({\n        ...configService.get('dbConnections.secret'),\n        entities: secretEntities,\n      }),\n    }),\n    GraphQLModule.forRootAsync({\n      // ...\n    }),\n    // other modules\n  ],\n  controllers: [],\n  providers: [],\n})\nexport class AppModule {}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Of course, there can only be one ",(0,r.jsx)(t.code,{children:"default"})," database connection. All other connections ",(0,r.jsx)(t.strong,{children:"must"})," have a proper ",(0,r.jsx)(t.code,{children:"name"})," set up. Further, this name ",(0,r.jsx)(t.strong,{children:"must"})," be used when connecting against this specific entity."]}),"\n",(0,r.jsx)(t.h2,{id:"create-a-new-feature-module",children:"Create a new Feature Module"}),"\n",(0,r.jsx)(t.p,{children:"Second, you need to create a new module for the feature that should store its data in another database using the previously defined connection."}),"\n",(0,r.jsxs)(t.p,{children:["First, define your ",(0,r.jsx)(t.code,{children:"Entity"})," class that is stored within the database"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",metastring:'title="secret/secret.entity.ts"',children:"import { Entity, Column } from 'typeorm';\n\n@Entity('secrets')\nexport class SecretEntity {\n  // some properties here, like\n  @Column()\n  name: string;\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["and the corresponding ",(0,r.jsx)(t.code,{children:"ObjectType"})," that is used for ",(0,r.jsx)(t.code,{children:"GraphQL"})]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",metastring:'title="secret/secret.dto.ts"',children:"import { ObjectType, Field } from '@nestjs/graphql';\n\n@ObjectType('Secret')\nexport class SecretDTO {\n  @Field()\n  name: string;\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Now lets register the ",(0,r.jsx)(t.code,{children:"SecretEntity"})," with ",(0,r.jsx)(t.code,{children:"NestjsQueryTypeOrmModule"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["The only difference is you need to pass the name of the ",(0,r.jsx)(t.code,{children:"Connection"})," when importing respective ",(0,r.jsx)(t.code,{children:"TypeOrmModule"}),"."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",metastring:'title="secret/secret.module.ts"',children:"import { Module } from '@nestjs/common';\nimport { NestjsQueryGraphQLModule } from '@ptc-org/nestjs-query-graphql';\nimport { NestjsQueryTypeOrmModule } from '@ptc-org/nestjs-query-typeorm'; \nimport { SECRET_DB_CONNECTION } from '../constants';\nimport { SecretEntity } from './secret.entity';\nimport { SecretDTO } from './secret.dto'\n\n@Module({\n  imports: [\n    NestjsQueryGraphQLModule.forFeature({\n      // import the NestjsQueryTypeOrmModule to register the entity with typeorm\n      // and provide a QueryService\n      imports: [\n        NestjsQueryTypeOrmModule.forFeature(\n          [SecretEntity], \n          SECRET_DB_CONNECTION, // specify the connection name\n        )\n      ],\n      // describe the resolvers you want to expose\n      resolvers: [{ DTOClass: SecretDTO, EntityClass: SecretEntity }],\n    }),\n    \n  ],  \n})\nexport class SecretModule {}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Now the ",(0,r.jsx)(t.code,{children:"NestjsQueryGraphQLModule"})," will create a ",(0,r.jsx)(t.code,{children:"Resolver"})," for the ",(0,r.jsx)(t.code,{children:"SecretDTO"})," and ",(0,r.jsx)(t.code,{children:"SecretEntity"})," that will use the custom connection."]}),"\n",(0,r.jsx)(t.h2,{id:"custom-typeormqueryservice",children:"Custom TypeOrmQueryService"}),"\n",(0,r.jsxs)(t.p,{children:["If you want to create a custom ",(0,r.jsx)(t.code,{children:"SecretService"})," responsible for the database access, a custom ",(0,r.jsx)(t.a,{href:"/nestjs-query/docs/persistence/services",children:"QueryService"}),", you need to pass an additional argument to the ",(0,r.jsx)(t.code,{children:"@InjectRepository()"})," decorator that indicates the ",(0,r.jsx)(t.code,{children:"Connection"})," you are using. This string has to match the ",(0,r.jsx)(t.code,{children:"name"})," property in the ",(0,r.jsx)(t.code,{children:"TypeOrmModule"})," options!"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",metastring:'title="secret/secret.service.ts"',children:"import { QueryService } from '@ptc-org/nestjs-query-core';\nimport { TypeOrmQueryService } from '@ptc-org/nestjs-query-typeorm';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { SECRET_DB_CONNECTION } from '../constants';\nimport { SecretEntity } from './secret.entity';\n\n@QueryService(SecretEntity)\nexport class SecretService extends TypeOrmQueryService<SecretEntity> {\n  constructor(\n    @InjectRepository(SecretEntity, SECRET_DB_CONNECTION) repository: Repository<SecretEntity>,\n  ) {\n    super(repository);\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["For the sake of brevity, the ",(0,r.jsx)(t.code,{children:"AssemblerService"})," is not covered here, as it should not directly interact with the database itself. Therefore, no further adaptations are required. This also applies to the ",(0,r.jsx)(t.code,{children:"Resolver"}),"!"]}),"\n",(0,r.jsxs)(t.p,{children:["For a full example see the ",(0,r.jsx)(t.a,{href:"https://github.com/tripss/nestjs-query/tree/master/examples/typeorm-multidb",children:"examples"}),"."]})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>c});var s=n(6540);const r={},o=s.createContext(r);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);