"use strict";(self.webpackChunknestjs_query=self.webpackChunknestjs_query||[]).push([[4236],{1756:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>c});var t=r(4848),i=r(8453);const s={title:"QueryService"},o=void 0,d={id:"concepts/services",title:"QueryService",description:"The core package defines a QueryService which is used to query and modify records.",source:"@site/docs/concepts/services.md",sourceDirName:"concepts",slug:"/concepts/services",permalink:"/nestjs-query/docs/concepts/services",draft:!1,unlisted:!1,editUrl:"https://github.com/tripss/nestjs-query/edit/master/documentation/docs/concepts/services.md",tags:[],version:"current",frontMatter:{title:"QueryService"},sidebar:"docs",previous:{title:"Queries",permalink:"/nestjs-query/docs/concepts/queries"},next:{title:"Assemblers",permalink:"/nestjs-query/docs/concepts/advanced/assemblers"}},l={},c=[{value:"Methods",id:"methods",level:2},{value:"<code>query</code>",id:"query",level:3},{value:"Arguments",id:"arguments",level:4},{value:"Returns",id:"returns",level:4},{value:"<code>findById</code>",id:"findbyid",level:3},{value:"Arguments",id:"arguments-1",level:4},{value:"Returns",id:"returns-1",level:4},{value:"<code>getById</code>",id:"getbyid",level:3},{value:"Arguments",id:"arguments-2",level:4},{value:"Returns",id:"returns-2",level:4},{value:"<code>createMany</code>",id:"createmany",level:3},{value:"Arguments",id:"arguments-3",level:4},{value:"Returns",id:"returns-3",level:4},{value:"<code>createOne</code>",id:"createone",level:3},{value:"Arguments",id:"arguments-4",level:4},{value:"Returns",id:"returns-4",level:4},{value:"<code>updateMany</code>",id:"updatemany",level:3},{value:"Arguments",id:"arguments-5",level:4},{value:"Returns",id:"returns-5",level:4},{value:"<code>updateOne</code>",id:"updateone",level:3},{value:"Arguments",id:"arguments-6",level:4},{value:"Returns",id:"returns-6",level:4},{value:"<code>deleteMany</code>",id:"deletemany",level:3},{value:"Arguments",id:"arguments-7",level:4},{value:"Returns",id:"returns-7",level:4},{value:"<code>deleteOne</code>",id:"deleteone",level:3},{value:"Arguments",id:"arguments-8",level:4},{value:"Returns",id:"returns-8",level:4},{value:"<code>aggregate</code>",id:"aggregate",level:3},{value:"Arguments",id:"arguments-9",level:4},{value:"Returns",id:"returns-9",level:4},{value:"<code>count</code>",id:"count",level:3},{value:"Arguments",id:"arguments-10",level:4},{value:"Returns",id:"returns-10",level:4},{value:"<code>queryRelations</code>",id:"queryrelations",level:3},{value:"Arguments",id:"arguments-11",level:4},{value:"Returns",id:"returns-11",level:4},{value:"<code>aggregateRelations</code>",id:"aggregaterelations",level:3},{value:"Arguments",id:"arguments-12",level:4},{value:"Returns",id:"returns-12",level:4},{value:"<code>countRelations</code>",id:"countrelations",level:3},{value:"Arguments",id:"arguments-13",level:4},{value:"Returns",id:"returns-13",level:4},{value:"<code>findRelation</code>",id:"findrelation",level:3},{value:"Arguments",id:"arguments-14",level:4},{value:"Returns",id:"returns-14",level:4},{value:"<code>addRelations</code>",id:"addrelations",level:3},{value:"Arguments",id:"arguments-15",level:4},{value:"Returns",id:"returns-15",level:4},{value:"<code>setRelations</code>",id:"setrelations",level:3},{value:"Arguments",id:"arguments-16",level:4},{value:"Returns",id:"returns-16",level:4},{value:"<code>setRelation</code>",id:"setrelation",level:3},{value:"Arguments",id:"arguments-17",level:4},{value:"Returns",id:"returns-17",level:4},{value:"<code>removeRelations</code>",id:"removerelations",level:3},{value:"Arguments",id:"arguments-18",level:4},{value:"Returns",id:"returns-18",level:4},{value:"<code>removeRelation</code>",id:"removerelation",level:3},{value:"Arguments",id:"arguments-19",level:4},{value:"Returns",id:"returns-19",level:4},{value:"Service Helpers",id:"service-helpers",level:2},{value:"RelationQueryService",id:"relationqueryservice",level:3},{value:"ProxyQueryService",id:"proxyqueryservice",level:3},{value:"NoOpQueryService",id:"noopqueryservice",level:3}];function a(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"core"})," package defines a ",(0,t.jsx)(n.code,{children:"QueryService"})," which is used to query and modify records."]}),"\n",(0,t.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,t.jsxs)(n.p,{children:["The following methods are defined on the ",(0,t.jsx)(n.code,{children:"QueryService"})]}),"\n",(0,t.jsx)(n.h3,{id:"query",children:(0,t.jsx)(n.code,{children:"query"})}),"\n",(0,t.jsx)(n.p,{children:"Query for multiple records, with a filter, paging and sorting."}),"\n",(0,t.jsx)(n.h4,{id:"arguments",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"query: Query<DTO>"})," - The query to filter, page, and sort results."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns",children:"Returns"}),"\n",(0,t.jsx)(n.p,{children:"An array of DTOs"}),"\n",(0,t.jsx)(n.h3,{id:"findbyid",children:(0,t.jsx)(n.code,{children:"findById"})}),"\n",(0,t.jsx)(n.p,{children:"Find a record by its id."}),"\n",(0,t.jsx)(n.h4,{id:"arguments-1",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"id: string | number"})," - The id of the record to find"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns-1",children:"Returns"}),"\n",(0,t.jsx)(n.p,{children:"The DTO or undefined"}),"\n",(0,t.jsx)(n.h3,{id:"getbyid",children:(0,t.jsx)(n.code,{children:"getById"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"get a record by its id or return a rejected promise with a NotFound error."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"arguments-2",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"id: string | number"})," - The id of the record to find"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns-2",children:"Returns"}),"\n",(0,t.jsx)(n.p,{children:"The DTO or a NotFoundException."}),"\n",(0,t.jsx)(n.h3,{id:"createmany",children:(0,t.jsx)(n.code,{children:"createMany"})}),"\n",(0,t.jsx)(n.p,{children:"Create multiple records."}),"\n",(0,t.jsx)(n.h4,{id:"arguments-3",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"items: DeepPartial<DTO>[]"})," - An array of partial DTOs to persist"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns-3",children:"Returns"}),"\n",(0,t.jsx)(n.p,{children:"The saved DTOs."}),"\n",(0,t.jsx)(n.h3,{id:"createone",children:(0,t.jsx)(n.code,{children:"createOne"})}),"\n",(0,t.jsx)(n.p,{children:"Create a single DTO."}),"\n",(0,t.jsx)(n.h4,{id:"arguments-4",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"item: DeepPartial<DTO>"})," - A partial of the DTO to persist"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns-4",children:"Returns"}),"\n",(0,t.jsx)(n.p,{children:"The saved DTO"}),"\n",(0,t.jsx)(n.h3,{id:"updatemany",children:(0,t.jsx)(n.code,{children:"updateMany"})}),"\n",(0,t.jsx)(n.p,{children:"Update multiple records based on a filter."}),"\n",(0,t.jsx)(n.h4,{id:"arguments-5",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"update: DeepPartial<DTO>"})," - The update to apply"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"filter: Filter<DTO>"})," - A ",(0,t.jsx)(n.code,{children:"Filter"})," used to find the records to update"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns-5",children:"Returns"}),"\n",(0,t.jsxs)(n.p,{children:["An object with the ",(0,t.jsx)(n.code,{children:"updatedCount"})]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"UpdatedCount may be 0 if the database does not return the number of rows updated."})}),"\n",(0,t.jsx)(n.h3,{id:"updateone",children:(0,t.jsx)(n.code,{children:"updateOne"})}),"\n",(0,t.jsx)(n.p,{children:"Update a single record."}),"\n",(0,t.jsx)(n.h4,{id:"arguments-6",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"id: string | number"})," - The id of the record to update"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"update: DeepPartial<DTO>"})," - The update to apply"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns-6",children:"Returns"}),"\n",(0,t.jsx)(n.p,{children:"The updated DTO"}),"\n",(0,t.jsx)(n.h3,{id:"deletemany",children:(0,t.jsx)(n.code,{children:"deleteMany"})}),"\n",(0,t.jsx)(n.p,{children:"Delete multiple records."}),"\n",(0,t.jsx)(n.h4,{id:"arguments-7",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"filter: Filter<DTO>"})," - The filter to find the records to delete."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns-7",children:"Returns"}),"\n",(0,t.jsxs)(n.p,{children:["An object with a ",(0,t.jsx)(n.code,{children:"deletedCount"})," field."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"deletedCount"})," may be 0 if the database does not return the number of rows deleted."]})}),"\n",(0,t.jsx)(n.p,{children:":::"}),"\n",(0,t.jsx)(n.h3,{id:"deleteone",children:(0,t.jsx)(n.code,{children:"deleteOne"})}),"\n",(0,t.jsx)(n.p,{children:"Delete a single record."}),"\n",(0,t.jsx)(n.h4,{id:"arguments-8",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"id: number | string"})}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns-8",children:"Returns"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"Promise<DTO>"})}),"\n",(0,t.jsx)(n.h3,{id:"aggregate",children:(0,t.jsx)(n.code,{children:"aggregate"})}),"\n",(0,t.jsxs)(n.p,{children:["Performs an aggregate query, supported aggregate functions are ",(0,t.jsx)(n.code,{children:"groupBy"}),", ",(0,t.jsx)(n.code,{children:"count"}),", ",(0,t.jsx)(n.code,{children:"sum"}),", ",(0,t.jsx)(n.code,{children:"avg"}),", ",(0,t.jsx)(n.code,{children:"min"}),", and ",(0,t.jsx)(n.code,{children:"max"})]}),"\n",(0,t.jsx)(n.h4,{id:"arguments-9",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"filter: Filter<DTO>"})," - Additional filter to apply"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"aggregate: AggregateQuery<DTO>"})," - The aggregate query"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Example ",(0,t.jsx)(n.code,{children:"AggregateQuery"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"{\n  count: ['id'],\n  sum: ['priority'],\n  avg: ['priority'],\n  min: ['id', 'title'],\n  max: ['id', 'title']\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"returns-9",children:"Returns"}),"\n",(0,t.jsx)(n.p,{children:"An array of aggregate responses."}),"\n",(0,t.jsxs)(n.p,{children:["Example ",(0,t.jsx)(n.code,{children:"AggregateResponse"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"[\n  {\n    count: { id: 5 },\n    sum: { id: 10 },\n    avg: { id: 2.5 },\n    min: {id: 1, title: 'A Title'},\n    max: {id: 4, title: 'Z Title'}\n  }\n]\n"})}),"\n",(0,t.jsx)(n.h3,{id:"count",children:(0,t.jsx)(n.code,{children:"count"})}),"\n",(0,t.jsxs)(n.p,{children:["Count the number of records that match the ",(0,t.jsx)(n.code,{children:"filter"})]}),"\n",(0,t.jsx)(n.h4,{id:"arguments-10",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"filter: Filter<DTO>"})," - The filter a count records by"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns-10",children:"Returns"}),"\n",(0,t.jsxs)(n.p,{children:["A count of records that match the ",(0,t.jsx)(n.code,{children:"filter"})]}),"\n",(0,t.jsx)(n.h3,{id:"queryrelations",children:(0,t.jsx)(n.code,{children:"queryRelations"})}),"\n",(0,t.jsx)(n.p,{children:"Query for relations"}),"\n",(0,t.jsx)(n.h4,{id:"arguments-11",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"RelationClass: Class<Relation>"})," - The ",(0,t.jsx)(n.code,{children:"Class"})," type of the relation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"relationName: string"})," - The name of the relation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"dto: DTO | DTO[]"})," - The dto(s) to find the relations for."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"query: Query<Relation>"})," - Additional query to use when querying for relations."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns-11",children:"Returns"}),"\n",(0,t.jsxs)(n.p,{children:["If querying for relations for a single ",(0,t.jsx)(n.code,{children:"DTO"})," an array of relations will be returned.\nIf querying for relations for multiple ",(0,t.jsx)(n.code,{children:"DTOs"})," a map where the key is the ",(0,t.jsx)(n.code,{children:"DTO"})," and the value is the relations for the ",(0,t.jsx)(n.code,{children:"DTO"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"aggregaterelations",children:(0,t.jsx)(n.code,{children:"aggregateRelations"})}),"\n",(0,t.jsxs)(n.p,{children:["Performs an aggregate query for the relations of a ",(0,t.jsx)(n.code,{children:"DTO"}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"arguments-12",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"RelationClass: Class<Relation>"})," - The ",(0,t.jsx)(n.code,{children:"Class"})," type of the relation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"relationName: string"})," - The name of the relation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"dto: DTO | DTO[]"})," - The dto(s) to aggregate the relations for."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"filter: Filter<Relation>"})," - A ",(0,t.jsx)(n.code,{children:"filter"})," to apply when aggregating relations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"aggregate: AggregateQuery<Relation>"})," - The ",(0,t.jsx)(n.code,{children:"aggregateQuery"})," for the relations"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns-12",children:"Returns"}),"\n",(0,t.jsxs)(n.p,{children:["If aggregating relations for a single ",(0,t.jsx)(n.code,{children:"DTO"})," an ",(0,t.jsx)(n.code,{children:"AggregateResponse"})," for the dtos relations will be returned\nIf aggregating relations for multiple ",(0,t.jsx)(n.code,{children:"DTOs"})," a map where the key is the ",(0,t.jsx)(n.code,{children:"DTO"})," and the value is the ",(0,t.jsx)(n.code,{children:"AggregateResponse"})," for the dtos relations."]}),"\n",(0,t.jsx)(n.h3,{id:"countrelations",children:(0,t.jsx)(n.code,{children:"countRelations"})}),"\n",(0,t.jsx)(n.p,{children:"Counts the number of relations."}),"\n",(0,t.jsx)(n.h4,{id:"arguments-13",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"RelationClass: Class<Relation>"})," - The ",(0,t.jsx)(n.code,{children:"Class"})," type of the relation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"relationName: string"})," - The name of the relation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"dto: DTO | DTO[]"})," - The dto(s) to count the relations for."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"filter: Filter<Relation>"}),"- A ",(0,t.jsx)(n.code,{children:"filter"})," to apply when counting relations"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns-13",children:"Returns"}),"\n",(0,t.jsxs)(n.p,{children:["If counting relations for a single ",(0,t.jsx)(n.code,{children:"DTO"})," the relation count will be returned\nIf counting relations for multiple ",(0,t.jsx)(n.code,{children:"DTOs"})," a map where the key is the ",(0,t.jsx)(n.code,{children:"DTO"})," and the value is relation count for the dtos relations."]}),"\n",(0,t.jsx)(n.h3,{id:"findrelation",children:(0,t.jsx)(n.code,{children:"findRelation"})}),"\n",(0,t.jsxs)(n.p,{children:["Find a single relation for the ",(0,t.jsx)(n.code,{children:"DTO"}),"(s)."]}),"\n",(0,t.jsx)(n.h4,{id:"arguments-14",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"RelationClass: Class<Relation>"})," - The ",(0,t.jsx)(n.code,{children:"Class"})," type of the relation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"relationName: string"})," - The name of the relation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"dto: DTO | DTO[]"})," - The dto(s) to find the relation for."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"opts?: FindRelationOptions<Relation>"})," - Additional options to find a relation by."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns-14",children:"Returns"}),"\n",(0,t.jsxs)(n.p,{children:["If finding a relation for a single ",(0,t.jsx)(n.code,{children:"DTO"})," the relation or undefineding returned\nIf finding a relation for multiple ",(0,t.jsx)(n.code,{children:"DTOs"})," a map where the key is the ",(0,t.jsx)(n.code,{children:"DTO"})," and the value is the relation or undefined."]}),"\n",(0,t.jsx)(n.h3,{id:"addrelations",children:(0,t.jsx)(n.code,{children:"addRelations"})}),"\n",(0,t.jsxs)(n.p,{children:["Adds relations to a ",(0,t.jsx)(n.code,{children:"DTO"})]}),"\n",(0,t.jsx)(n.h4,{id:"arguments-15",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"relationName: string"})," - The name of the relation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"id: string | number"})," - The id of the DTO to add the relations to"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"relationIds: (string | number)[]"})," - The ids of the relations to add"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"opts?: ModifyRelationOptions<DTO, Relation>"})," - Additional options apply when adding relations"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns-15",children:"Returns"}),"\n",(0,t.jsx)(n.p,{children:"The DTO the relations were added to."}),"\n",(0,t.jsx)(n.h3,{id:"setrelations",children:(0,t.jsx)(n.code,{children:"setRelations"})}),"\n",(0,t.jsxs)(n.p,{children:["Sets relations on a ",(0,t.jsx)(n.code,{children:"DTO"})]}),"\n",(0,t.jsx)(n.h4,{id:"arguments-16",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"relationName: string"})," - The name of the relation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"id: string | number"})," - The id of the DTO to add the relations to"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"relationIds: (string | number)[]"})," - The ids of the relations to set. If the relationIds is empty the all relations will be removed."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"opts?: ModifyRelationOptions<DTO, Relation>"})," - Additional options apply when adding relations"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns-16",children:"Returns"}),"\n",(0,t.jsx)(n.p,{children:"The DTO the relations were added to."}),"\n",(0,t.jsx)(n.h3,{id:"setrelation",children:(0,t.jsx)(n.code,{children:"setRelation"})}),"\n",(0,t.jsx)(n.p,{children:"Set a relation on a DTO"}),"\n",(0,t.jsx)(n.h4,{id:"arguments-17",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"relationName: string"})," - The name of the relation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"id: string | number"})," - The id of the DTO to add the relations to"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"relationId: string | number"})," - The id of the relation to set on the DTO"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"opts?: ModifyRelationOptions<DTO, Relation>"})," - Additional options apply when setting the relation"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns-17",children:"Returns"}),"\n",(0,t.jsx)(n.p,{children:"The DTO the relation was set on."}),"\n",(0,t.jsx)(n.h3,{id:"removerelations",children:(0,t.jsx)(n.code,{children:"removeRelations"})}),"\n",(0,t.jsx)(n.p,{children:"Removes multiple relations from a DTO"}),"\n",(0,t.jsx)(n.h4,{id:"arguments-18",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"relationName: string"})," - The name of the relation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"id: string | number"})," - The id of the DTO to remove the relations from."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"relationIds: (string | number)[]"})," - The ids of the relations to remove"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"opts?: ModifyRelationOptions<DTO, Relation>"})," - Additional options to apply when removing relations"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns-18",children:"Returns"}),"\n",(0,t.jsx)(n.p,{children:"The DTO the relations were removed from"}),"\n",(0,t.jsx)(n.h3,{id:"removerelation",children:(0,t.jsx)(n.code,{children:"removeRelation"})}),"\n",(0,t.jsx)(n.p,{children:"Remove a relation from a DTO"}),"\n",(0,t.jsx)(n.h4,{id:"arguments-19",children:"Arguments"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"relationName: string"})," - The name of the relation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"id: string | number"})," - The id of the DTO to remove the relation from."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"relationId: string | number"})," - The id of the relation to remove"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"opts?: ModifyRelationOptions<DTO, Relation>"})," - Additional options to apply when removing the relation."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns-19",children:"Returns"}),"\n",(0,t.jsx)(n.p,{children:"The DTO the relation was removed from."}),"\n",(0,t.jsx)(n.h2,{id:"service-helpers",children:"Service Helpers"}),"\n",(0,t.jsxs)(n.p,{children:["You can create your own service to use with the ",(0,t.jsx)(n.code,{children:"CRUDResolver"})," as long as it implements the ",(0,t.jsx)(n.code,{children:"QueryService"})," interface."]}),"\n",(0,t.jsxs)(n.p,{children:["There are a number of persistence ",(0,t.jsx)(n.code,{children:"QueryServices"})," that are provided out of the box."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/nestjs-query/docs/persistence/typeorm/getting-started",children:"@ptc-org/nestjs-query-typeorm"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/nestjs-query/docs/persistence/sequelize/getting-started",children:"@ptc-org/nestjs-query-sequelize"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/nestjs-query/docs/persistence/mongoose/getting-started",children:"@ptc-org/nestjs-query-mongoose"})}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["In addition to the persistence ",(0,t.jsx)(n.code,{children:"QueryServices"})," ",(0,t.jsx)(n.code,{children:"@ptc-org/nestjs-query-core"})," provides a few helper services that can be used for more complex use cases."]}),"\n",(0,t.jsx)(n.p,{children:"When designing the base services we have chosen composition over inheritance. This approach lends itself well to modeling complex services without repeating yourself."}),"\n",(0,t.jsx)(n.h3,{id:"relationqueryservice",children:"RelationQueryService"}),"\n",(0,t.jsxs)(n.p,{children:["The RelationQueryService was originally designed for ",(0,t.jsx)(n.a,{href:"/nestjs-query/docs/graphql/federation",children:"federation"}),", but has proven itself useful in representing virtual relations. A virtual relation(s) is anything that can be queried through a query service."]}),"\n",(0,t.jsx)(n.p,{children:"To create additional relations through a RelationQueryService you need to provide the following"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.code,{children:"QueryService"})," that can be used to fetch the relation"]}),"\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.code,{children:"query"})," function that accepts the parent DTO to fetch the relation for and returns a ",(0,t.jsx)(n.code,{children:"Query"})," to fetch the relations."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["Relations defined using the ",(0,t.jsx)(n.code,{children:"RelationQueryService"})," are readonly!"]})}),"\n",(0,t.jsx)(n.p,{children:"When a relation query method is called it will:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["First check if the relation is a virtual relation, if ",(0,t.jsx)(n.code,{children:"true"})," it will invoke the ",(0,t.jsx)(n.code,{children:"query"})," option to generate a query that will be\npassed to the ",(0,t.jsx)(n.code,{children:"queryService"})," to fetch the relations."]}),"\n",(0,t.jsxs)(n.li,{children:["If the relation is not a ",(0,t.jsx)(n.code,{children:"virtual"})," relation it will proxy to the original query service to query for the relation."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For example, we could wrap the ",(0,t.jsx)(n.code,{children:"TodoItem"})," query service and add a ",(0,t.jsx)(n.code,{children:"completedSubTasks"})," relation."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="todo-item/todo-item.service.ts"',children:"import { InjectQueryService, QueryService, RelationQueryService } from '@ptc-org/nestjs-query-core';\nimport { TodoItemEntity } from './todo-item.entity';\nimport { SubTaskEntity } from '../sub-task/sub-task.entity';\n\nexport class TodoItemService extends RelationQueryService<TodoItemEntity> {\n  constructor(\n    @InjectQueryService(TodoItemEntity) queryService: QueryService<TodoItemEntity>,\n    @InjectQueryService(SubTaskEntity) subTaskQueryService: QueryService<SubTaskEntity>,\n  ) {\n    // provide the original query service so all relations defined in the ORM work\n    super(queryService, {\n      // specify the virtual relations\n      completedSubTasks: {\n        // provide the service that will be used to query the relation\n        service: subTaskQueryService,\n        // the query method accepts a todoItem that can be used to filter the relations\n        query(todoItem) {\n          // filter for all relations that belong to the todoItem and are completed\n          return { filter: { todoItemId: { eq: todoItem.id }, completed: { is: true } } };\n        },\n      },\n    });\n  }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Once the ",(0,t.jsx)(n.code,{children:"relation"})," is defined in the query service we can add it to our ",(0,t.jsx)(n.code,{children:"DTO"})," to expose it in our schema."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="todo-item/todo-item.dto.ts"',children:"import { FilterableField, IDField, FilterableConnection, KeySet } from '@ptc-org/nestjs-query-graphql';\nimport { ObjectType, ID, GraphQLISODateTime, Field } from '@nestjs/graphql';\nimport { SubTaskDTO } from '../../sub-task/dto/sub-task.dto';\n\n@ObjectType('TodoItem')\n@KeySet(['id'])\n@FilterableConnection('subTasks', () => SubTaskDTO)\n@FilterableConnection('completedSubTasks', () => SubTaskDTO)\nexport class TodoItemDTO {\n  @IDField(() => ID)\n  id!: number;\n\n  @FilterableField()\n  title!: string;\n\n  @FilterableField({ nullable: true })\n  description?: string;\n\n  @FilterableField()\n  completed!: boolean;\n\n  @FilterableField(() => GraphQLISODateTime)\n  created!: Date;\n\n  @FilterableField(() => GraphQLISODateTime)\n  updated!: Date;\n}\n\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Next we need to export the ",(0,t.jsx)(n.code,{children:"SubTask"})," query service from the ",(0,t.jsx)(n.code,{children:"SubTaskModule"})," so we can resolve it in the\n",(0,t.jsx)(n.code,{children:"TodoItemService"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:"title='sub-task/sub-task.module.ts'",children:"import { NestjsQueryGraphQLModule } from '@ptc-org/nestjs-query-graphql';\nimport { NestjsQueryTypeOrmModule } from '@ptc-org/nestjs-query-typeorm';\nimport { Module } from '@nestjs/common';\nimport { SubTaskDTO } from './dto/sub-task.dto';\nimport { SubTaskEntity } from './sub-task.entity';\n\n// define the persistence module so it can be exported\nconst nestjsQueryTypeOrmModule = NestjsQueryTypeOrmModule.forFeature([SubTaskEntity]);\n\n@Module({\n  imports: [\n    NestjsQueryGraphQLModule.forFeature({\n      // import it in the graphql module\n      imports: [nestjsQueryTypeOrmModule],\n      resolvers: [\n        {\n          DTOClass: SubTaskDTO,\n          EntityClass: SubTaskEntity,\n        },\n      ],\n    }),\n    // import it into the subTaskModule so it can be exported\n    nestjsQueryTypeOrmModule,\n  ],\n  // export the persistence module so it can be used by the TodoItemService\n  exports: [nestjsQueryTypeOrmModule],\n})\nexport class SubTaskModule {}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Now we can import the ",(0,t.jsx)(n.code,{children:"SubTaskModule"})," into the ",(0,t.jsx)(n.code,{children:"TodoItemModule"})," so the ",(0,t.jsx)(n.code,{children:"SubTask"})," query service can be injected into\nthe ",(0,t.jsx)(n.code,{children:"TodoItemService"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="todo-item/todo-item.module.ts"',children:"import { NestjsQueryGraphQLModule } from '@ptc-org/nestjs-query-graphql';\nimport { NestjsQueryTypeOrmModule } from '@ptc-org/nestjs-query-typeorm';\nimport { Module } from '@nestjs/common';\nimport { TodoItemDTO } from './dto/todo-item.dto';\nimport { TodoItemAssembler } from './todo-item.assembler';\nimport { TodoItemEntity } from './todo-item.entity';\nimport { TodoItemResolver } from './todo-item.resolver';\nimport { TodoItemService } from './todo-item.service';\nimport { SubTaskModule } from '../sub-task/sub-task.module';\n\n@Module({\n  providers: [TodoItemResolver],\n  imports: [\n    NestjsQueryGraphQLModule.forFeature({\n      // import the persistence module for the TodoItemEntity and the SubTaskModule\n      imports: [NestjsQueryTypeOrmModule.forFeature([TodoItemEntity]), SubTaskModule],\n      services: [TodoItemService],\n      assemblers: [TodoItemAssembler],\n      resolvers: [\n        {\n          DTOClass: TodoItemDTO,\n          ServiceClass: TodoItemService,\n        },\n      ],\n    }),\n  ],\n})\nexport class TodoItemModule {}\n\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"completedSubTasks"})," relation is now available in your graphql schema."]}),"\n",(0,t.jsx)(n.h3,{id:"proxyqueryservice",children:"ProxyQueryService"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ProxyQueryService"})," is a query service that delegates to another query service. The ",(0,t.jsx)(n.code,{children:"ProxyQueryService"})," can be used when you want to override certain methods of a query service without extending it."]}),"\n",(0,t.jsxs)(n.p,{children:["This class is used internally by the ",(0,t.jsx)(n.a,{href:"#relationqueryservice",children:"RelationQueryService"})," to override the relation methods for a ",(0,t.jsx)(n.code,{children:"QueryService"})]}),"\n",(0,t.jsxs)(n.p,{children:["Lets use the ",(0,t.jsx)(n.code,{children:"ProxyQueryService"})," to create a generic query service that will time and log a message everytime a ",(0,t.jsx)(n.code,{children:"create"}),", ",(0,t.jsx)(n.code,{children:"update"}),", or ",(0,t.jsx)(n.code,{children:"delete"})," method is called."]}),"\n",(0,t.jsxs)(n.p,{children:["To start lets define a ",(0,t.jsx)(n.code,{children:"MutationLoggerQueryService"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="utilities/mutation-logger-query.service.ts"',children:"import { Logger, LoggerService } from '@nestjs/common';\nimport { DeepPartial } from '../common';\nimport { Filter, DeleteManyResponse, DeleteOneOptions, UpdateManyResponse, UpdateOneOptions } from '../interfaces';\nimport { ProxyQueryService } from './proxy-query.service';\nimport { QueryService } from './query.service';\n\nexport class MutationLoggerQueryService<DTO, C = DeepPartial<DTO>, U = DeepPartial<DTO>> extends ProxyQueryService<\n  DTO,\n  C,\n  U\n> {\n  private readonly logger: LoggerService;\n\n  constructor(label: string, queryService: QueryService<DTO, C, U>) {\n    // call super witht the QueryService we will delegate to\n    super(queryService);\n    // create our logger\n    this.logger = new Logger(label);\n  }\n\n  // Override all the create, update, and delete methods to add the timed logging functionality\n  createMany(items: C[]): Promise<DTO[]> {\n    return this.timedLog(`create many [itemCount=${items.length}]`, () => super.createMany(items));\n  }\n\n  createOne(item: C): Promise<DTO> {\n    return this.timedLog(`create one`, () => super.createOne(item));\n  }\n\n  deleteMany(filter: Filter<DTO>): Promise<DeleteManyResponse> {\n    return this.timedLog(`delete many`, () => super.deleteMany(filter));\n  }\n\n  deleteOne(id: number | string, opts?: DeleteOneOptions<DTO>): Promise<DTO> {\n    return this.timedLog(`delete one [id=${id}]`, () => super.deleteOne(id, opts));\n  }\n\n  updateMany(update: U, filter: Filter<DTO>): Promise<UpdateManyResponse> {\n    return this.timedLog('update many', () => super.updateMany(update, filter));\n  }\n\n  updateOne(id: string | number, update: U, opts?: UpdateOneOptions<DTO>): Promise<DTO> {\n    return this.timedLog(`update one [id=${id}]`, () => super.updateOne(id, update, opts));\n  }\n\n  private async timedLog<T>(message, fn: () => Promise<T>): Promise<T> {\n    const start = new Date();\n    const result = await fn();\n    const duration = start.getTime() - new Date().getTime();\n    this.logger.log(`${message} [duration=${duration}]`);\n    return result;\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"We can now add timed logging to any query service."}),"\n",(0,t.jsxs)(n.p,{children:["Lets add it to our ",(0,t.jsx)(n.code,{children:"TodoItemQueryService"})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="todo-item/todo-item.service.ts"',children:"import { InjectQueryService, QueryService } from '@ptc-org/nestjs-query-core';\nimport { MutationLoggerQueryService } from '../utilities/mutation-logger-query.service';\nimport { TodoItemEntity } from './todo-item.entity';\n\n@QueryService(TodoItemEntity)\nexport class TodoItemService extends MutationLoggerQueryService<TodoItemEntity> {\n  constructor(@InjectQueryService(TodoItemEntity) service: QueryService<TodoItemEntity>) {\n    // provide the logger name and the service\n    super(TodoItemService.name, service);\n  }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Don't forget to use your custom query service in your module"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",metastring:'title="todo-item/todo-item.module.ts"',children:"import { NestjsQueryGraphQLModule } from '@ptc-org/nestjs-query-graphql';\nimport { NestjsQueryTypeOrmModule } from '@ptc-org/nestjs-query-typeorm';\nimport { Module } from '@nestjs/common';\nimport { TodoItemDTO } from './dto/todo-item.dto';\nimport { TodoItemEntity } from './todo-item.entity';\nimport { TodoItemService } from './todo-item.service';\n\n@Module({\n  imports: [\n    NestjsQueryGraphQLModule.forFeature({\n      imports: [NestjsQueryTypeOrmModule.forFeature([TodoItemEntity])],\n      services: [TodoItemService],\n      resolvers: [\n        {\n          DTOClass: TodoItemDTO,\n          ServiceClass: TodoItemService,\n        },\n      ],\n    }),\n  ],\n})\nexport class TodoItemModule {}\n\n"})}),"\n",(0,t.jsx)(n.h3,{id:"noopqueryservice",children:"NoOpQueryService"}),"\n",(0,t.jsxs)(n.p,{children:["The no-op query service is one that will throw a ",(0,t.jsx)(n.code,{children:"NotImplementedException"})," for every method."]}),"\n",(0,t.jsx)(n.p,{children:"This is commonly used during testing when you want to mock out a service."}),"\n",(0,t.jsxs)(n.p,{children:["You can also use the ",(0,t.jsx)(n.code,{children:"NoOpQueryService"})," as a base a new query service that only supports a subset of operations."]}),"\n",(0,t.jsx)(n.p,{children:"In this example we'll create a simple query service that stores elements in an array but does not support relations or aggregations."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"import {\n  applyFilter,\n  applyQuery,\n  DeleteManyResponse,\n  DeleteOneOptions,\n  Filter,\n  FindByIdOptions,\n  GetByIdOptions,\n  NoOpQueryService,\n  Query,\n  QueryService,\n  UpdateManyResponse,\n  UpdateOneOptions,\n} from '@ptc-org/nestjs-query-core';\nimport { NotFoundException } from '@nestjs/common';\nimport { TodoItemEntity } from './todo-item.entity';\n\n@QueryService(TodoItemEntity)\nexport class TodoItemService extends NoOpQueryService<TodoItemEntity> {\n  private records: TodoItemEntity[];\n\n  constructor() {\n    super();\n    this.records = [];\n  }\n\n  createMany(items: TodoItemEntity[]): Promise<TodoItemEntity[]> {\n    this.records.push(...items);\n    return Promise.resolve(items);\n  }\n\n  createOne(item: TodoItemEntity): Promise<TodoItemEntity> {\n    this.records.push(item);\n    return Promise.resolve(item);\n  }\n\n  async updateMany(update: Partial<TodoItemEntity>, filter: Filter<TodoItemEntity>): Promise<UpdateManyResponse> {\n    const recordsToUpdate = await this.query({ filter });\n    recordsToUpdate.forEach((r) => Object.assign(r, update));\n    return { updatedCount: recordsToUpdate.length };\n  }\n\n  async updateOne(\n    id: string | number,\n    update: Partial<TodoItemEntity>,\n    opts?: UpdateOneOptions<TodoItemEntity>,\n  ): Promise<TodoItemEntity> {\n    const record = await this.getById(id, opts);\n    return Object.assign(record, update);\n  }\n\n  async deleteMany(filter: Filter<TodoItemEntity>): Promise<DeleteManyResponse> {\n    const recordIds = (await this.query({ filter })).map((r) => r.id);\n    this.records = this.records.filter((r) => !recordIds.includes(r.id));\n    return Promise.resolve({ deletedCount: recordIds.length });\n  }\n\n  async deleteOne(id: number | string, opts?: DeleteOneOptions<TodoItemEntity>): Promise<TodoItemEntity> {\n    const record = await this.getById(id, opts);\n    this.records = this.records.filter((r) => r.id !== record.id);\n    return Promise.resolve(record);\n  }\n\n  findById(id: string | number, opts?: FindByIdOptions<TodoItemEntity>): Promise<TodoItemEntity | undefined> {\n    const record = applyFilter(this.records, opts?.filter ?? {}).find((r) => r.id === id);\n    return Promise.resolve(record);\n  }\n\n  async getById(id: string | number, opts?: GetByIdOptions<TodoItemEntity>): Promise<TodoItemEntity> {\n    const record = await this.findById(id, opts);\n    if (!record) {\n      throw new NotFoundException(`Unable to find TodoItem with id ${id}`);\n    }\n    return record;\n  }\n\n  query(query: Query<TodoItemEntity>): Promise<TodoItemEntity[]> {\n    return Promise.resolve(applyQuery(this.records, query));\n  }\n\n  async count(filter: Filter<TodoItemEntity>): Promise<number> {\n    const found = await this.query({ filter });\n    return found.length;\n  }\n}\n\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>d});var t=r(6540);const i={},s=t.createContext(i);function o(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);